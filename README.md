# CocosGame
Built for cocos game project

## （一）游戏启动方法
1. 进入游戏目录
2. 启动CocosGame.exe
3. 成功进入游戏

## （二）游玩模式选择和注意事项
### 游玩须知
+ 游戏中所有场景的切换间为了良好的视觉效果均设置有一定的延迟，因此点击开始游戏后场景没有立即切换是正常现象，如果反复不停多次连续点击开始游戏可能导致游戏卡死乃至崩溃。
+ 游戏如果使用笔记本游玩需要使用外接鼠标进行点击操作，如果使用触摸板点击可能没有任何效果。  
+ **重要注意项：游戏exe所在文件夹的全部上级路径中不能含有任何中文，否则会导致背景音乐无法播放！！**
### 单人模式
+ 菜单界面选择**Press To Start**进入设置名字界面
+ 设置名字界面输入玩家名字后选择**Confirm**进入游戏模式选择界面
+ 游戏模式选择界面选择**Single Player**开始游戏
### 多人模式
+ 菜单界面选择**Press To Start**进入设置名字界面
+ 设置名字界面输入玩家名字后选择**Confirm**进入游戏模式选择界面
+ 在游戏模式选择界面可以“**Create Room**”或者“**Join Room**”
+ 选择“**Create Room**”，玩家创建房间作为服务端进行游戏，点击界面“**+**”或“**-**”号可以添加/移除电脑玩家，上方标签显示当前加入的其它玩家姓名，如果无玩家加入则显示“**Wait for Joining**”，服务端随时可以点击“**Let's Roll**"来开始游戏。
+ 选择“**Join Room**”，玩家加入房间作为客户端进行游戏，在界面**IP地址输入框** 输入服务端IP地址，点击**connect**发出连接请求，如果连接成功上方标签1显示**Connected** ，如果加入房间成功上方标签2显示**Joined host+主机地址**, 如果房间已满或服务端游戏已开始则标签2显示Can't Join加入失败。加入房间后请等待服务端开始游戏。
### 郊游模式
+ 在主界面选择开启**Field Trip Mode**后，游戏场景中将不会自动生成敌人，需要手动通过输入/addTarget命令添加敌人。（对客户端该模式无效，服务端开启后对客户端同样生效）
### 自定义添加背景音乐
+ 将音乐文件放入游戏目录下Resources/Audio/BG目录下，再通过游戏内歌曲控制面板切换播放

## （三）游戏操作
### 基本按键操作
|按键|效果|
|---|---|
|W|向前移动|
|S|向后移动|
|A|向左移动|
|D|向右移动|
|R|更换子弹|
|F|快速切换至近战武器并进行近战攻击|
|鼠标左键|开火|
|鼠标移动|控制准心位置|
|Shift+任意移动键|快速翻滚移动（消耗体力值）|
|数字键1~7|切换武器栏1~7|
|enter回车键|打开文本输入框/发送文本输入框内聊天信息|
|ESC|打开游戏中设置菜单（有返回游戏选项和返回主菜单选项）|
### 作弊指令
1. 按Enter呼出文本输入框
2. 输入有效作弊指令，目前支持:  
 
|指令|效果|
|---|----|
|/invincible|无敌|
|/allWeapons|允许使用所有武器|
|/aimbot|子弹自动瞄准|
|/infiniteAmmo|无限弹药|
|/addTarget|添加敌人|
|/addAi|添加电脑玩家|
**注意:**输入作弊指令效果为切换作弊指令开关状态，如果原来作弊开启输入指令后作弊将会关闭
### 聊天系统
1. 按Enter呼出文本输入框
2. 输入聊天内容并发送，所有玩家的聊天信息将显示在上方聊天栏中，聊天栏自动隐藏。
### 掉落拾取系统
+ 游戏开始所有玩家只可以使用近战武器，通过击杀敌人拾取掉落可以解锁其它武器的使用权。
+ 击杀敌人后会随机掉落一种可拾取物品，包括武器和特殊效果道具，将人物移动到物品上可自动拾取，拾取未解锁的武器将解锁该武器对应的武器栏，拾取已解锁的武器将自动转换为相应的弹药。
### 游戏成为吃鸡者条件
+ 单人模式下，击杀敌人取得10000分即可成为吃鸡者
+ 多人模式下，玩家团队协作击杀敌人取得10000分后，所有存活的玩家全部为吃鸡者
+ 吃鸡者名单将在游戏胜利后显示在结束画面中
+ 玩家间**不能**互相攻击

# 2021高级程序设计期末项目总结文档  
## 项目信息介绍  
### **项目名称：**
+ 鸡地求生（POBG) 
### **项目成员：**
+ 2050250
### **小组成员贡献比例：**
|组员|贡献比例|
|-------|--------|
|2050250|100%|
### **GitHub地址：**
+ [https://github.com/leo4048111/CocosGame](https://github.com/leo4048111/CocosGame)
### **项目进度时间线**
|时间段|项目进度|
|:-----------:|:-----------:|
|2021.4.25|coco2dx平台搭建 + GitHub网址建设|
|2021.4.26 ~ 2021.5.5|1.0游戏界面搭建，基础游戏逻辑设计|
|2021.5.6 ~ 2021.5.11|完善游戏基础功能，增加掉落机制|
|2021.5.12 ~ 2021.5.20|编写ai移动和攻击逻辑，完善玩家射击与移动算法逻辑|
|2021.5.21 ~ 2021.5.24|增加聊天系统和作弊系统，单人游戏模式完成|
|2021.5.25 ~ 2021.5.28|2.0游戏界面搭建，增加多人游戏功能，可视化ui更新，增加武器掉落机制，支持添加电脑玩家，将若干类修改为单例，完善游戏动画效果|
|2021.5.29 ~ 2021.6.1|增加音频控制面板，支持玩家自定义背景音乐快捷导入|
|2021.6.2 ~ 2021.6.5|Socket客户端和服务端类封装|
|2021.6.6 ~ 2021.6.15|3.0游戏界面搭建，游戏地图设计，添加障碍物和边界，引入开源Json库cJsonObject用于json数据处理，完善服务端和客户端通信机制，进一步完善游戏动画效果、基础功能和创新功能|
|2021.6.16 ~ 2021.6.20|游戏总体功能完善，增加Field Trip模式用于项目演示，增加与完善若干ui显示效果，完善文档|
## 项目开发文档
### **（一）项目整体架构：**
#### **1.项目背景:**  
+ 使用cocos引擎开发一款支持单人游戏和联机游戏的鸡地求生小游戏  
#### **2.核心功能：**  
+ 单人游玩，多人联机
#### **3.性能与安全：**  
+ **单人游玩**时性能稳定，运行流畅，**小于5人联机时**联机响应延迟较低，总体性能优良  
+ **内存管理机制**较为完备，**单人游戏**时不会出现内存泄漏与访问异常，多人联机时在**服务端性能较差**的情况下偶尔发生异常  
+ 总体测试下**Socket通信**数据传输稳定并且具有较高的安全性
### **（二）实现的功能点：**  
#### **1.基础功能点：**  
+ 游戏开始界面，玩家昵称自定义，游戏模式选择，背景音乐，退出功能、计时系统、美观且具有边界和障碍物的地图
+ 支持创建房间和加入房间，支持添加ai玩家和玩家加入
+ 通过键盘控制人物走动、翻滚、换弹等操作，鼠标控制准星移动和射击方向
+ 支持积分系统，积分实时显示在游戏界面左上角
+ 吃鸡者：单人模式时玩家达到积分上限即为吃鸡者，多人模式时最先达到积分上限的玩家即为吃鸡者
#### **2.创新功能点：**  

+ 游戏场景随机生成障碍物，使得每次游戏都是一个全新场景，在一定程度上增强了游戏的可玩性

+ 游戏背景音乐支持自定义添加和游戏中切换
+ 敌人死亡掉落多种bonus道具（回复血量、增加速度、增加体力、增加体力恢复、增加弹药和增加护甲）和多种武器
+ 共有8种武器可供使用，各自具有独特的动画特效和攻击方式
+ 支持快捷使用近战武器
+ 小地图工具，实时显示玩家位置和敌人位置，大大增强游戏趣味性
+ 共有4类不同敌人，具有不同的攻击方式和攻击特效
+ 聊天系统，支持单机/联机玩家聊天
+ 作弊系统，支持无敌、无限弹药、解锁所有武器和自动瞄准
### **(三）技术难点及解决方案&过程**  
1. **游戏人物连续移动：难度系数1/10**   
项目初期遇到第一个难点是如何通过持续按下移动按键实现人物的连续移动。为了实现这一效果，创建了一个map对象来记录每个按键当前的状态是否为按下，通过在按键按下或放开后更新这一状态，最后在每一帧中通过update函数根据每个按键的状态更新人物位置，实现了连续移动的效果。
2. **层间坐标转换:难度系数1/10**  
基础功能实现中，另一难点是在实现定向射击等功能时的层间坐标转换。通过查阅相关资料，发现可以通过将所有坐标先通过convertToWorldSpace方法转换为世界坐标，再通过convertToNodeSpace方法转换为节点坐标的方式实现准确的层间坐标转换。
3. **游戏设置数据的管理:难度系数2/10**  
游戏中需要实现大量设置数据的层间共享，如果通过反复传参的方法会非常麻烦。所以该项目维护了一个Specs单例用于保存相关设置数据，在需要访问时直接通过getInstance方法获取单例进行访问即可，大大简化了代码逻辑。
4. **类实例数据的序列化:难度系数3/10**  
在Socket通信过程中需要实现大量类实例数据的实时收发，因此本项目引入了一个开源Json库cJsonObject用以json数据的打包和解析，通过将相关类实例数据提取后打包发送再收取解析，变相地实现了类实例数据的序列化和实时通信。
5. **子弹层管理和碰撞检测:难度系数6/10**  
项目中期子弹层经常出现内存泄漏和碰撞检测无效的问题，经过反复调试排查原因，最终建立了一套完善的子弹层内存管理机制和碰撞检测机制，使得玩家游玩时不会游戏崩溃，极大地提高了游戏软件的健壮性、趣味性与可靠性。  
6. **端对端通信机制的设计:难度系数5/10**  
Socket通信中由于涉及大量数据收发，需要对于数据类型进行标识，因此引入枚举类型来标识数据类型，在onRecv函数中根据数据类型不同，经由switch语句分别执行不同操作，使得数据管理井井有条，同时代码的可拓展性大大提升。
7. **AI移动和攻击逻辑的设计：难度系数1/10**  
实现一个精妙的AI移动和攻击逻辑需要一个较为高级的算法，所以在经过反复的失败尝试后，最终发现随机移动和随机选取目标攻击能够呈现一个比较理想的效果，因此目前ai敌人每次移动和攻击时会选择一个随机玩家，而ai玩家在攻击时会选择一个随机敌人。
8. **大量精灵的管理：难度系数4/10**  
为了有效管理大量精灵的交互，将精灵分为若干类别，从中抽象出Entity基类并且分层，使得精灵的管理变得井井有条，切实贯彻了场景->层->精灵的这一基本cocos软件架构思路。  
9. **Socket服务端和客户端的封装与再封装：难度系数8/10**  
本项目的SocketClient和SocketServer类封装参考了开源项目代码 [https://blog.csdn.net/ctxdecs/article/details/43888399](https://blog.csdn.net/ctxdecs/article/details/43888399)。分别为**（1）对于WinSock2中各种基本Socket接口的封装（2）接收数据后不直接处理而是将消息加入_UIMessageQueue数组，随后将数据处理方法写在update函数中，用cocos2dx的scheduler调度器逐帧调用update方法来处理数据这一端数据处理模式。** 而针对该项目实际的应用情况，做出了一定的改动：**（1）SocketServer类和SocketClient类修改为单例类，构建了一套完善的实例创建和销毁机制（2）为了解决原封装存在的TCP黏包问题，修改了原封装的数据收发机制（详见难点10解析）（3）原封装在销毁实例时存在线程未退出继续访问该实例导致错误的问题，因此在项目中对于这一问题进行了修复（4）对于原封装在若干机制设计上的不足进行了优化，根据项目需要添加若干接口（5）主线程销毁实例时增加了Sleep机制等待子线程退出，防止了子线程访问无效内存地址**，有效提高了Socket服务端和客户端在实际应用场景下的健壮性与可靠性。
10. **Socket通信中解决TCP黏包:难度系数5/10**  
程序调试中发现采用TCP协议的Socket通信存在数据黏包的问题，于是想到可以先发送一个类似同步标识的4字节整型变量，标识之后数据包大小，再发送响应大小的数据包。接收时根据包大小进行接收。实际编程中通过设计一个包含一个int变量和char*指针的结构体，发数据前将数据打包成结构体再发送，收数据前首先通过Recv函数接收该int变量，用以标识之后将要接收的数据包的总大小，再通过Recv函数接收相应大小的数据，有效解决了TCP黏包的问题。
11. **Socket服务端和客户端实现中线程互斥机制设计：难度系数10/10**  
Socket编程中为了避免收发数据造成的线程阻塞，需要用到多线程技术，首先服务端每次与客户端建立新连接时创建新线程进行通信时需要建立新线程进行收发防止recv函数阻塞主线程。其中涉及到对于类成员的访问尤其是数据修改时，经常出现一些内存访问冲突问题。因此，使用了c++11中的std::mutex互斥变量，访问可能存在访问冲突变量时上锁，建立了一套较为完备的互斥访问机制，解决了这一问题。

### **（四）亮点**  
#### **1.大量且合理地使用了C++功能**  
+ 包括但不限于：STL容器，迭代器，类和多态，模板，函数重载，C++11和以上功能。
#### **2.代码基本遵循microsoft c++ style，且与cocos引擎源码代码风格保持一致，具有高可读性和高美观度**
#### **3.类封装合理**
#### **4.尽可能地使用了c++风格的类型转换**  
+ 如`dynamic_cast`、`const_cast`

#### **5.界面和UI设计遵循用户友好的原则，简洁而功能健全**

